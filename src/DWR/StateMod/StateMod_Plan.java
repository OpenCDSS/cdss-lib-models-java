// StateMod_Plan - class to store plan information

/* NoticeStart

CDSS Models Java Library
CDSS Models Java Library is a part of Colorado's Decision Support Systems (CDSS)
Copyright (C) 1994-2019 Colorado Department of Natural Resources

CDSS Models Java Library is free software:  you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    CDSS Models Java Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CDSS Models Java Library.  If not, see <https://www.gnu.org/licenses/>.

NoticeEnd */

package DWR.StateMod;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Vector;

import RTi.GIS.GeoView.GeoRecord;
import RTi.GIS.GeoView.HasGeoRecord;
import RTi.Util.IO.IOUtil;
import RTi.Util.Message.Message;
import RTi.Util.String.StringUtil;

/**
Object used to store plan information.  All set routines set
the COMP_PLANS flag dirty.  A new object will have empty non-null
lists, null time series, and defaults for all other data.
*/
public class StateMod_Plan extends StateMod_Data
implements Cloneable, Comparable<StateMod_Data>, HasGeoRecord
{

// ID, name, river node (cgoto), and switch are in the base class.

/**
Plan type.
*/
protected int _iPlnTyp;

/**
Plan efficiency flag.
*/
protected int _PeffFlag;

/**
Plan efficiency.
*/
protected double[] _Peff = new double[12]; // only used if _PeffFlag = 1, but set aside memory

/**
Return flow table.
*/
protected int _iPrf;

/**
Plan failure switch.
*/
protected int _iPfail;

/**
Initial plan storage value (AF).
*/
protected double _Psto1;

/**
Source ID of structure where reuse water became available or a T&C condition
originated (for type 8).
*/
protected String _Psource;

/**
Source account of structure where reuse water became available or a T&C condition
originated (for type 8).  Treat as a string but is an integer in StateMod so right-justify output.
*/
protected String _iPAcc;

/**
Reference to spatial data for this plan -- currently NOT cloned.
*/
protected GeoRecord _georecord;

/**
Comments provided by user - # comments before each plan.  An empty (non-null) list is guaranteed.
TODO SAM 2010-12-14 Evaluate whether this can be in StateMod_Data or will it bloat memory.
*/
protected List<String> __commentsBeforeData = new Vector<String>();

/**
Construct a new plan and assign data to reasonable defaults.
*/
public StateMod_Plan()
{	super();
	initialize ( true );
}

/**
Construct a new plan.
@param initialize_defaults If true, assign data to reasonable defaults.
If false, all data are set to missing.
*/
public StateMod_Plan ( boolean initialize_defaults )
{	super();
	initialize ( initialize_defaults );
}

/**
Copy constructor.
@param deep_copy If true, make a deep copy including secondary vectors of data.
Currently only false is recognized, in which primitive data are copied.  This is
suitable to allow the StateMod_Plan_JFrame class to know when changes have
been made to data on the main screen.
*/
public StateMod_Plan ( StateMod_Plan plan, boolean deep_copy )
{	this();
	// Base class...
	// TODO
	// Local data members...
	_iPlnTyp = plan._iPlnTyp;
	_PeffFlag = plan._PeffFlag;
	_iPrf = plan._iPrf;
	_iPfail = plan._iPfail;
	_Psto1 = plan._Psto1;
	_Psource = plan._Psource;
	_georecord = plan._georecord;
}

/**
Accepts any changes made inside of a GUI to this object.
*/
public void acceptChanges() {
	_isClone = false;
	_original = null;
}

/**
Compares this object with its original value (generated by createBackup() upon
entering a GUI) to see if it has changed.
*/
public boolean changed() {
	if (_original == null) {
		return true;
	}
	if (compareTo(_original) == 0) {
		return false;
	}
	return true;
}

/**
Clones the data object.
@return a cloned object.
*/
public Object clone() {
	StateMod_Plan plan = (StateMod_Plan)super.clone();
	plan._isClone = true;
	return plan;
}

/**
Compares this object to another StateMod_Plan object.
@param data the object to compare against.
@return 0 if they are the same, 1 if this object is greater than the other
object, or -1 if it is less.
*/
public int compareTo(StateMod_Data data) {
	int res = super.compareTo(data);
	if (res != 0) {
		return res;
	}

	// TODO SAM 2007-03-01 Need to enable
	//StateMod_Plan p = (StateMod_Plan)o;

/* TODO SAM 2006-08-22 need to review
	if (_divcap < d._divcap) {
		return -1;
	}
	else if (_divcap > d._divcap) {
		return 1;
	}
	
	res = _username.compareTo(d._username);
	if (res != 0) {
		return res;
	}

	if (_idvcom < d._idvcom) {
		return -1;
	}
	else if (_idvcom > d._idvcom) {
		return 1;
	}

	if (_divefc < d._divefc) {
		return -1;
	}
	else if (_divefc > d._divefc) {
		return 1;
	}

	if (_area < d._area) {
		return -1;
	}
	else if (_area > d._area) {
		return 1;
	}

	if (_irturn < d._irturn) {
		return -1;
	}
	else if (_irturn > d._irturn) {
		return 1;
	}
	
	if (_demsrc < d._demsrc) {
		return -1;
	}
	else if (_demsrc > d._demsrc) {
		return 1;
	}

	if (_ireptype < d._ireptype) {
		return -1;
	}
	else if (_ireptype > d._ireptype) {
		return 1;
	}

	if (_awc < d._awc) {
		return -1;
	}
	else if (_awc > d._awc) {
		return 1;
	}

	if (_diveff == null && d._diveff == null) {
		return 0;
	}
	else if (_diveff == null && d._diveff != null) {
		return -1;
	}
	else if (_diveff != null && d._diveff == null) {
		return 1;
	}
	else {
		int size1 = _diveff.length;
		int size2 = d._diveff.length;
		if (size1 < size2) {
			return -1;
		}
		else if (size1 > size2) {
			return 1;
		}
		
		for (int i = 0; i < size1; i++) {
			if (_diveff[i] < d._diveff[i]) {
				return -1;
			}
			else if (_diveff[i] > d._diveff[i]) {
				return 1;
			}
		}
	}
*/

	return 0;
}

/**
Creates a copy of the object for later use in checking to see if it was changed in a GUI.
*/
public void createBackup() {
	_original = (StateMod_Plan)clone();
	((StateMod_Plan)_original)._isClone = false;
	_isClone = true;
}

/**
Clean up for garbage collection.
*/
protected void finalize()
throws Throwable {
	_Psource = null;
	_georecord = null;
	super.finalize();
}

/**
Return the comments from the input file that immediate precede the data.
@return the comments from the input file that immediate precede the data.
*/
public List<String> getCommentsBeforeData() {
	return __commentsBeforeData;
}

/**
Get the geographical data associated with the plan.
@return the GeoRecord for the plan.
*/
public GeoRecord getGeoRecord() {
	return _georecord;
}

/**
Return the account of the source structure.
*/
public String getIPAcc() {
	return _iPAcc;
}

/**
Return the plan fail flag.
*/
public int getIPfail() {
	return _iPfail;
}

/**
Return a list of failure flag option strings, for use in GUIs.
The options are of the form "0" if include_notes is false and
"0 - Do not turn plan off if it fails", if include_notes is true.
@return a list of plan type switch option strings, for use in GUIs.
@param include_notes Indicate whether notes should be added after the parameter values.
*/
public static List<String> getIPfailChoices ( boolean include_notes )
{	List<String> v = new Vector<String>(2);
	v.add ( "0 - Do not turn plan off if it fails" );
	v.add ( "1 - Turn plan off if it fails" );
	if ( !include_notes ) {
		// Remove the trailing notes...
		int size = v.size();
		for ( int i = 0; i < size; i++ ) {
			v.set(i,StringUtil.getToken(v.get(i), " ", 0, 0) );
		}
	}
	return v;
}

/**
Return the default failure switch choice.  This can be used by GUI code
to pick a default for a new plan.
@return the default plan type choice.
*/
public static String getIPfailDefault ( boolean include_notes )
{	// Make this agree with the above method...
	if ( include_notes ) {
		return "0 - Do not turn plan off if it fails";
	}
	else {
		return "0";
	}
}

/**
Return the plan type.
*/
public int getIPlnTyp() {
	return _iPlnTyp;
}

/**
Return a list of plan type option strings, for use in GUIs.
The options are of the form "1" if include_notes is false and
"1 - Terms and Conditions (T&C)", if include_notes is true.
@return a list of plan type switch option strings, for use in GUIs.
@param include_notes Indicate whether notes should be added after the parameter values.
*/
public static List<String> getIPlnTypChoices ( boolean include_notes )
{	List<String> v = new Vector<String>(9);
	v.add ( "1 - Terms and Conditions (T&C)" );
	v.add ( "2 - Well Augmentation" );
	v.add ( "3 - Reuse to a Reservoir" );
	v.add ( "4 - Reuse to a Diversion" );
	v.add ( "5 - Reuse to a Reservoir from Transmountain" );
	v.add ( "6 - Reuse to a Diversion from Transmountain" );
	v.add ( "7 - Transmountain import" );
	v.add ( "8 - Recharge Plan" );
	v.add ( "9 - Out-of-Priority Diversion or Storage" );
	v.add ( "10 - Special Well Augmentation" );
	v.add ( "11 - Accounting Plan" );
	v.add ( "12 - Release Limit Plan" );
	if ( !include_notes ) {
		// Remove the trailing notes...
		int size = v.size();
		for ( int i = 0; i < size; i++ ) {
			v.set(i,StringUtil.getToken( v.get(i), " ", 0, 0) );
		}
	}
	return v;
}

/**
Return the default plan type choice.  This can be used by GUI code
to pick a default for a new plan.
@return the default plan type choice.
*/
public static String getIPlnTypDefault ( boolean include_notes )
{	// Make this agree with the above method...
	if ( include_notes ) {
		return ( "1 - Terms and Conditions (T&C)" );
	}
	else {
		return "1";
	}
}

/**
Return the plan efficiency for a specific month.
@param imon the efficiency month (0+, where 0 is the first month according to the data set control file)
*/
public double getPeff(int imon)
{
	return _Peff[imon];
}

/**
Return the plan efficiency flag.
*/
public int getPeffFlag()
{
	return _PeffFlag;
}

/**
Return a list of efficiency flag option strings, for use in GUIs.
The options are of the form "0" if include_notes is false and
"0 - Off", if include_notes is true.
@return a list of on/off switch option strings, for use in GUIs.
@param includeNotes Indicate whether notes should be added after the parameter values.
*/
public static List<String> getPeffFlagChoices ( boolean includeNotes )
{	List<String> v = new Vector<String>(2);
	v.add ( "0 - Not used" );
	v.add ( "1 - Specify 12 plan efficiency values" );
	v.add ( "999 - Use source structure's efficiency values" );
	if ( !includeNotes ) {
		// Remove the trailing notes...
		int size = v.size();
		for ( int i = 0; i < size; i++ ) {
			v.set(i,StringUtil.getToken( v.get(i), " ", 0, 0) );
		}
	}
	return v;
}

/**
Return the plan efficiency flag choice.  This can be used by GUI code to pick a default for a new plan.
@return the default plan efficiency choice.
*/
public static String getPeffFlagDefault ( boolean includeNotes )
{	// Make this agree with the above method...
	if ( includeNotes ) {
		return ( "999 - use source structure's efficiency values" );
	}
	else {
		return "999";
	}
}

/**
Return a list of on/off switch option strings, for use in GUIs.
The options are of the form "0" if include_notes is false and
"0 - Off", if include_notes is true.
@return a list of on/off switch option strings, for use in GUIs.
@param include_notes Indicate whether notes should be added after the parameter values.
*/
public static List<String> getPonChoices ( boolean include_notes )
{	List<String> v = new Vector<String>(2);
	v.add ( "0 - Off" );	// Possible options are listed here.
	v.add ( "1 - On" );
	if ( !include_notes ) {
		// Remove the trailing notes...
		int size = v.size();
		for ( int i = 0; i < size; i++ ) {
			v.set(i,StringUtil.getToken( v.get(i), " ", 0, 0) );
		}
	}
	return v;
}

/**
Return the default on/off switch choice.  This can be used by GUI code
to pick a default for a new plan.
@return the default reservoir replacement choice.
*/
public static String getPonDefault ( boolean include_notes )
{	// Make this agree with the above method...
	if ( include_notes ) {
		return ( "1 - On" );
	}
	else {
		return "1";
	}
}

/**
Return the return flow table.
*/
public int getIPrf() {
	return _iPrf;
}

/**
Return a list of return flow type option strings, for use in GUIs.
The options are of the form "0" if includeNotes is false and
"0 - not used", if include_notes is true.
@return a list of plan type switch option strings, for use in GUIs.
@param includeNotes Indicate whether notes should be added after the parameter values.
*/
public static List<String> getIPrfChoices ( boolean includeNotes )
{	List<String> v = new Vector<String>(2);
	v.add ( "0 - no return flows calculated" );
	v.add ( "1 - T&C plan with return data in plan return file" );
	v.add ( "8 - Recharge plan with return data in plan return file" );
	v.add ( "999 - use source structure's return flow data" );
	if ( !includeNotes ) {
		// Remove the trailing notes...
		int size = v.size();
		for ( int i = 0; i < size; i++ ) {
			v.set(i,StringUtil.getToken(v.get(i), " ", 0, 0) );
		}
	}
	return v;
}

/**
Return the default return flow type choice.  This can be used by GUI code
to pick a default for a new plan.
@return the default plan type choice.
*/
public static String getIPrfDefault ( boolean includeNotes )
{	// Make this agree with the above method...
	if ( includeNotes ) {
		return "999 - use source structure's return flow data";
	}
	else {
		return "999";
	}
}

/**
Return the ID of the source structure.
*/
public String getPsource() {
	return _Psource;
}

/**
Return the plan initial storage.
*/
public double getPsto1() {
	return _Psto1;
}

/**
Initialize data.
Sets the smdata_type to _dataset.COMP_PLANS.
@param initialize_defaults If true, assign data to reasonable defaults.
If false, all data are set to missing.
*/
private void initialize ( boolean initialize_defaults )
{	_smdata_type = StateMod_DataSet.COMP_PLANS;
	if ( initialize_defaults ) {
		_iPlnTyp = 1;
		_PeffFlag = 999;
		_iPrf = 999;
		_iPfail = 0;
		_Psto1 = 0.0;
		_Psource = "";
		_iPAcc = "";
	}
	else {
		// Use missing data...
		_iPlnTyp = StateMod_Util.MISSING_INT;
		_PeffFlag = StateMod_Util.MISSING_INT;
		_iPrf = StateMod_Util.MISSING_INT;
		_iPfail = StateMod_Util.MISSING_INT;
		_Psto1 = StateMod_Util.MISSING_DOUBLE;
		_Psource = StateMod_Util.MISSING_STRING;
		_iPAcc = StateMod_Util.MISSING_STRING;;
	}
	_georecord = null;
}

/**
Indicate whether a file is a StateMod plan file.  Currently the only
check that is done is to see if the file name ends in "pln".
@param filename File name.
@return true if the file appears to be a plan file, false if not.
*/
public static boolean isStateModPlanFile ( String filename )
{	if ( StringUtil.endsWithIgnoreCase(filename,".pln") ) {
		return true;
	}
	return false;
}

/**
Read plan information in and store in a list.
@param filename filename containing plan information
@throws Exception if an error occurs
*/
public static List<StateMod_Plan> readStateModFile(String filename)
throws Exception
{	String routine = "StateMod_Plan.readStateModFile";
	String iline = null;
	List<String> v = new Vector<String>(9);
	List<StateMod_Plan> thePlans = new Vector<StateMod_Plan>();
	int linecount = 0;
	
	StateMod_Plan aPlan = null;
	BufferedReader in = null;

	Message.printStatus(2, routine, "Reading plan file: " + filename);
	int size = 0;
	int errorCount = 0;
	try {	
		in = new BufferedReader(new FileReader(IOUtil.getPathUsingWorkingDir(filename)));
		List<String> commentsBeforeData = new Vector<String>();
		while ((iline = in.readLine()) != null) {
			++linecount;
			// check for comments
			if (iline.startsWith("#>") || (iline.trim().length()== 0) ) {
				// Special dynamic header comments written by software and blank lines - no need to keep
				continue;
			}
			else if (iline.startsWith("#") ) {
				// Comment prior to a plan - do not trim so that input/output comparisons can be made but
				// do remove the initial comment character
				commentsBeforeData.add ( iline.substring(1) );
				continue;
			}

			if (Message.isDebugOn) {
				Message.printDebug(50, routine, "line: " + iline);
			}
			// Break the line using whitespace, while allowing for quoted strings...
			v = StringUtil.breakStringList (
				iline, " \t", StringUtil.DELIM_ALLOW_STRINGS|StringUtil.DELIM_SKIP_BLANKS );
			size = 0;
			if ( v != null ) {
				size = v.size();
			}
			if ( size < 11 ) {
				Message.printStatus ( 2, routine, "Ignoring line " + linecount +
				" not enough data values.  Have " + size + " expecting " + 11 );
				++errorCount;
				continue;
			}
			// Uncomment if testing...
			//Message.printStatus ( 2, routine, "" + v );

			// Allocate new plan node and set the values
			aPlan = new StateMod_Plan();
			aPlan.setID(v.get(0).trim()); 
			aPlan.setName(v.get(1).trim()); 
			aPlan.setCgoto(v.get(2).trim());
			aPlan.setSwitch(v.get(3).trim());
			aPlan.setIPlnTyp(v.get(4).trim());
			aPlan.setPeffFlag(v.get(5).trim());
			int peffFlag = aPlan.getPeffFlag();
			aPlan.setIPrf(v.get(6).trim());
			aPlan.setIPfail(v.get(7).trim());
			aPlan.setPsto1(v.get(8).trim());
			aPlan.setPsource(v.get(9).trim());
			aPlan.setIPAcc(v.get(10).trim());
			
			// Read the efficiencies...
			
			if ( peffFlag == 1 ) {
				iline = in.readLine();
				++linecount;
				if( iline == null ) {
					throw new IOException ( "Unexpected end of file after line " + linecount +
						" - expecting 12 efficiency values.");
				}
				v = StringUtil.breakStringList (
					iline, " \t", StringUtil.DELIM_ALLOW_STRINGS|StringUtil.DELIM_SKIP_BLANKS );
				size = 0;
				if ( v != null ) {
					size = v.size();
				}
				if ( size != 12 ) {
					Message.printStatus ( 2, routine, "Ignoring line " + linecount +
					" not enough data values.  Have " + size + " expecting " + 12 );
					++errorCount;
				}
				else {
					for ( int iEff = 0; iEff < 12; iEff++ ) {
						String val = v.get(0).trim();
						try {
							aPlan.setPeff(iEff,Double.parseDouble(val));
						}
						catch ( Exception e ) {
							Message.printStatus ( 2, routine, "Efficiencies on line " + linecount +
								" value \"" + val + "\" is not a number." );
								++errorCount;
						}
					}
				}
			}
			
			// Set the comments
			
			if ( commentsBeforeData.size() > 0 ) {
				// Set comments that have been read previous to this line.  First, attempt to discard
				// comments that do not below with the operational right.  For now, search backward for
				// "EndHeader" and "--e" which indicate the end of the header.  If found, discard the comments prior
				// to this because they are assumed to be file header comments, not comments for a specific right.
				// Only do this for the first right because the user may actually want to include the header
				// information in their file periodically to help with formatting
				String comment;
				if ( thePlans.size() == 0 ) {
					for ( int iComment = commentsBeforeData.size() - 1; iComment >= 0; --iComment ) {
						comment = commentsBeforeData.get(iComment).toUpperCase();
						if ( (comment.indexOf("ENDHEADER") >= 0) || (comment.indexOf("--E") >= 0) ) {
							// Remove the comments above the position.
							while ( iComment >= 0 ) {
								commentsBeforeData.remove(iComment--);
							}
							break;
						}
					}
				}
				aPlan.setCommentsBeforeData(commentsBeforeData);
			}
			// Always clear out for next right...
			commentsBeforeData = new Vector<String>(1);

			// Set the plan to not dirty because it was just initialized...

			aPlan.setDirty ( false );

			// Add the plan to the vector of plans
			thePlans.add(aPlan);
		}
	} 
	catch (Exception e) {
		Message.printWarning(3, routine, "Error reading line " + linecount + " \"" + iline + "\" (" + e + ")." );
		Message.printWarning(3, routine, e);
		throw e;
	}
	finally {
		if (in != null) {
			in.close();
		}
	}
	if ( errorCount > 0 ) {
		throw new Exception ( "There were " + errorCount + " errors processing the data - refer to log file." );
	}
	return thePlans;
}

/**
Cancels any changes made to this object within a GUI since createBackup()
was called and sets _original to null.
*/
public void restoreOriginal() {
	StateMod_Plan plan = (StateMod_Plan)_original;
	super.restoreOriginal();

	_iPlnTyp = plan._iPlnTyp;
	_PeffFlag = plan._PeffFlag;
	_iPrf = plan._iPrf;
	_iPfail = plan._iPfail;
	_Psto1 = plan._Psto1;
	_Psource = plan._Psource;
	_isClone = false;
	_original = null;
}

/**
Set the comments before the data in the input file.
@param commentsBeforeData comments before the data in the input file.
*/
public void setCommentsBeforeData(List<String> commentsBeforeData)
{	boolean dirty = false;
	int size = commentsBeforeData.size();
	List<String> commentsBeforeData0 = getCommentsBeforeData();
	if ( size != commentsBeforeData0.size() ) {
		dirty = true;
	}
	else {
		// Lists are the same size and there may not have been any changes
		// Need to check each string in the comments
		for ( int i = 0; i < size; i++ ) {
			if ( !commentsBeforeData.get(i).equals(commentsBeforeData0.get(i))) {
				dirty = true;
				break;
			}
		}
	}
	if ( dirty ) {
		// Something was different so set the comments and change the dirty flag
		__commentsBeforeData = commentsBeforeData;
		setDirty ( true );
		if ( !_isClone && _dataset != null ) {
			_dataset.setDirty(StateMod_DataSet.COMP_PLANS,true);
		}
	}
}

/**
Set the plan failure flag.
@param iPfail Plan failure flag.
*/
public void setIPfail(int iPfail) {
	if (iPfail != _iPfail) {
		_iPfail = iPfail;
		setDirty(true);
		if ( !_isClone && _dataset != null ) {
			_dataset.setDirty( StateMod_DataSet.COMP_PLANS, true);
		}
	}
}

/**
Set the plan failure flag.
@param iPfail plan failure flag.
*/
public void setIPfail(Integer iPfail) {
	setIPfail(iPfail.intValue());
}

/**
Set the plan failure flag.
@param iPfail plan failure flag.
*/
public void setIPfail(String iPfail) {
	if (iPfail == null) {
		return;
	}
	setIPfail(StringUtil.atoi(iPfail.trim()));
}

/**
Set the plan return flow table.
@param iPrf Plan return flow table.
*/
public void setIPrf(int iPrf) {
	if (iPrf != _iPrf) {
		_iPrf = iPrf;
		setDirty(true);
		if ( !_isClone && _dataset != null ) {
			_dataset.setDirty( StateMod_DataSet.COMP_PLANS, true);
		}
	}
}

/**
Set the plan return flow table.
@param iPrf plan return flow table.
*/
public void setIPrf(Integer iPrf) {
	setIPrf(iPrf.intValue());
}

/**
Set the plan return flow table.
@param iPrf plan return flow table.
*/
public void setIPrf(String iPrf) {
	if (iPrf == null) {
		return;
	}
	setIPrf(StringUtil.atoi(iPrf.trim()));
}

/**
Set the geographic information object associated with the plan.
@param georecord Geographic record associated with the plan.
*/
public void setGeoRecord ( GeoRecord georecord )
{	_georecord = georecord;
}

/**
Set the source account.
@param iPAcc source account.
*/
public void setIPAcc(String iPAcc) {
	if (iPAcc == null) {
		return;
	}
	if (!iPAcc.equals(_iPAcc)) {
		_iPAcc = iPAcc;
		setDirty(true);
		if ( !_isClone && _dataset != null ) {
			_dataset.setDirty( StateMod_DataSet.COMP_PLANS, true);
		}
	}
}

/**
Set the plan type.
@param iPlnTyp Plan type.
*/
public void setIPlnTyp(int iPlnTyp) {
	if (iPlnTyp != _iPlnTyp) {
		_iPlnTyp = iPlnTyp;
		setDirty(true);
		if ( !_isClone && _dataset != null ) {
			_dataset.setDirty( StateMod_DataSet.COMP_PLANS, true);
		}
	}
}

/**
Set the plan type.
@param iPlnTyp plan type.
*/
public void setIPlnTyp(Integer iPlnTyp) {
	setIPlnTyp(iPlnTyp.intValue());
}

/**
Set the plan type.
@param iPlnTyp plan type.
*/
public void setIPlnTyp(String iPlnTyp) {
	if (iPlnTyp == null) {
		return;
	}
	setIPlnTyp(StringUtil.atoi(iPlnTyp.trim()));
}

/**
Set the plan efficiency for a particular month.
The efficiencies are stored in the order of the year for the data set.  For
example, if water years are used, the first efficiency will be for October.  For
calendar year, the first efficiency will be for January.
@param index month index (0+)
@param peff monthly efficiency
*/
public void setPeff(int index, double peff) {
	if (_Peff[index] != peff) {
		_Peff[index] = peff;
		setDirty(true);
		if ( !_isClone && _dataset != null ) {
			_dataset.setDirty(StateMod_DataSet.COMP_PLANS, true);
		}
	}
}

/**
Set the plan efficiency flag.
@param peff plan efficiency flag.
*/
public void setPeffFlag(int PeffFlag) {
	if (_PeffFlag != PeffFlag) {
		_PeffFlag = PeffFlag;
		setDirty(true);
		// TODO SAM 2006-08-22 Take out after initial troubleshooting is complete
		//Message.printStatus ( 2, "", "Setting object dirty = true" );
		//String s = "not null";
		//if ( _dataset == null ) {
		//	s = "null";
		//}
		//Message.printStatus ( 2, "", "_isClone=" + _isClone + " _dataset="+s );
		if ( !_isClone && _dataset != null ) {
			_dataset.setDirty( StateMod_DataSet.COMP_PLANS, true);
			//Message.printStatus ( 2, "", "Is data set dirt?"  + _dataset.isDirty() );
		}
	}
}

/**
Set the plan efficiency flag.
@param PeffFlag plan efficiency flag.
*/
public void setPeffFlag (Integer PeffFlag) {
	setPeffFlag (PeffFlag.intValue());
}

/**
Set the plan efficiency.
@param PeffFlag Plan efficiency.
*/
public void setPeffFlag(String PeffFlag) {
	if (PeffFlag == null) {
		return;
	}
	setPeffFlag(StringUtil.atoi(PeffFlag.trim()));
}

/**
Set the source id.
@param Psource source id.
*/
public void setPsource(String Psource) {
	if (Psource == null) {
		return;
	}
	if (!Psource.equals(_Psource)) {
		_Psource = Psource;
		setDirty(true);
		if ( !_isClone && _dataset != null ) {
			_dataset.setDirty( StateMod_DataSet.COMP_PLANS, true);
		}
	}
}

/**
Set the plan initial storage.
@param peff plan initial storage.
*/
public void setPsto1(double Psto1) {
	if (_Psto1 != Psto1) {
		_Psto1 = Psto1;
		setDirty(true);
		if ( !_isClone && _dataset != null ) {
			_dataset.setDirty( StateMod_DataSet.COMP_PLANS, true);
		}
	}
}

/**
Set the plan initial storage.
@param Psto1 plan initial storage.
*/
public void setPsto1 (Double Psto1) {
	setPsto1 (Psto1.doubleValue());
}

/**
Set the plan initial storage.
@param Peff Plan initial storage.
*/
public void setPsto1(String Psto1) {
	if (Psto1 == null) {
		return;
	}
	setPsto1(StringUtil.atod(Psto1.trim()));
}

/**
Write plan information to output.  History header information 
is also maintained by calling this routine.
@param instrfile input file from which previous history should be taken
@param outstrfile output file to which to write
@param thePlans list of plans to write.
@param newComments addition comments which should be included in history
@exception Exception if an error occurs.
*/
public static void writeStateModFile(String instrfile, String outstrfile,
		List<StateMod_Plan> thePlans, List<String> newComments )
throws Exception
{	String routine = "StateMod_Plan.writeStateModFile";
	List<String> commentIndicators = new Vector<String>(1);
	commentIndicators.add ( "#" );
	List<String> ignoredCommentIndicators = new Vector<String>(1);
	ignoredCommentIndicators.add ( "#>");
	PrintWriter out = null;
	try {
		out = IOUtil.processFileHeaders(
			IOUtil.getPathUsingWorkingDir(instrfile),
			IOUtil.getPathUsingWorkingDir(outstrfile), 
			newComments, commentIndicators, ignoredCommentIndicators, 0);

		int i;
		String iline;
		String cmnt = "#>";
		// This format follows historical conventions
		String formatLine1 = "%-12.12s \"%-24.24s\" %-12.12s%8d%8d%8d%8d%8d%8d \"%-12.12s\" %8.8s";
		StateMod_Plan plan = null;
		List<Object> v = new Vector<Object>(11); // Reuse for all output lines.

		out.println(cmnt);
		out.println(cmnt + "*************************************************");
		out.println(cmnt + "  StateMod Plan Stations");
		out.println(cmnt);
		out.println(cmnt + "  Card 1 format:  Free, default used is: a12,2x,a24,2x,a12,1x,6i8,2x,a12,i8)" );
		out.println(cmnt + "                  The default format is consistent with internal data sizes." );
		out.println(cmnt + "                  Strings containing spaces should be enclosed in quotes." );
		out.println(cmnt + "                  Variable names are provided below consistent with documentation." );
		out.println(cmnt);
		out.println(cmnt + "  ID                Pid:  Plan ID");
		out.println(cmnt + "  Name            Pname:  Plan name");
		out.println(cmnt + "  River Node      iPsta:  River node for plan");
		out.println(cmnt + "  On/Off            Pon:  Switch 0=off, 1=on");
		out.println(cmnt + "  Type          iPlnTyp:  Plan type");
		out.println(cmnt + "                          1=Terms and Conditions (T&C)");
		out.println(cmnt + "                          2=Well Augmentation");
		out.println(cmnt + "                          3=CU Reuse to a Reservoir");
		out.println(cmnt + "                          4=CU Reuse to a Diversion");
		out.println(cmnt + "                          5=CU Reuse to a Reservoir from Tmtn");
		out.println(cmnt + "                          6=CU Reuse to a Diversion from Tmtn");
		out.println(cmnt + "                          7=Tmtn Reuse");
		out.println(cmnt + "                          8=Recharge Plan");
		out.println(cmnt + "                          9=OOP Plan");
		out.println(cmnt + "                          10=Special Well Augmentation Plan");
		out.println(cmnt + "                          11=Accounting Plan");
		out.println(cmnt + "                          12=Release Limit Plan");
		out.println(cmnt + "  Eff              Peff:  Plan efficiency (%)");
		out.println(cmnt + "                          0=do not use" );
		out.println(cmnt + "                          1=following line will have 12 monthly efficiencies." );
		out.println(cmnt + "                          999=use source structure's efficiencies" );
		out.println(cmnt + "  RetType          iPrf:  Return flow typ." );
		out.println(cmnt + "                          0=no return flows calculated" );
		out.println(cmnt + "                          1=T&C plan with return data in plan return flow file" );
		out.println(cmnt + "                          8=Recharge plan with return data in plan return flow file" );
		out.println(cmnt + "                          999=use source structure's return flow data" );
		out.println(cmnt + "  Fail           iPfail:  Failure switch" );
		out.println(cmnt + "                          0=Do not turn plan off if failure");
		out.println(cmnt + "                          1=turn plan off if it fails");
		out.println(cmnt + "  Storage         Psto1:  Initial storage (AF)" );
		out.println(cmnt + "  Source        PSource:  Source ID of structure where plan water becomes available" );
		out.println(cmnt + "  Account         iPAcc:  Source account of structure where plan water becomes available" );
		out.println(cmnt);
		out.println(cmnt + " ID          Name                      RiverLoc    On/Off  iPtype  Peff    iPrf    " +
				"iPfail  Psto1     Psource       PAcct");
		out.println(cmnt + "---------exxb----------------------exxb----------eb------eb------eb------eb------e" +
				"b------eb------exxb----------exxb------e");
		out.println(cmnt + "EndHeader");

		int num = 0;
		if (thePlans != null) {
			num = thePlans.size();
		}
		for (i = 0; i < num; i++) {
			plan = thePlans.get(i);
			if (plan == null) {
				continue;
			}
			
			// Comments before data.
			
			List<String> commentsBeforeData = plan.getCommentsBeforeData();
			int numComments = commentsBeforeData.size();
			// Print the comments in front of the operational right
			// The original comments were stripped of the leading # but otherwise are padded with whitespace
			// as per the original - when written they should exactly match the original
			for (int j = 0; j < numComments; j++) {
				out.println("#" + commentsBeforeData.get(j));
			}

			// line 1
			v.clear();
			v.add(plan.getID());
			v.add(plan.getName());
			v.add(plan.getCgoto());
			v.add(new Integer(plan.getSwitch()));
			v.add(new Integer(plan.getIPlnTyp()));
			v.add(new Integer(plan.getPeffFlag()));
			v.add(new Integer(plan.getIPrf()));
			v.add(new Integer(plan.getIPfail()));
			v.add(new Double(plan.getPsto1()));
			v.add(plan.getPsource());
			v.add(plan.getIPAcc());
			iline = StringUtil.formatString(v, formatLine1);
			out.println(iline);
			
			// Line 2
			
			if ( plan.getPeffFlag() == 1 ) {
				for ( int iEff = 0; iEff < 12; iEff++ ) {
					if ( iEff > 0 ) {
						out.print(" ");
					}
					out.print(StringUtil.formatString(plan.getPeff(iEff),"%6.2f") );
				}
				out.println ("");
			}
		}
	} 
	catch (Exception e) {
		Message.printWarning(3, routine, e);
		throw e;
	}
	finally {
		if (out != null) {
			out.flush();
			out.close();
		}
	}
}

// TODO SAM 2006-08-22
// Enable when plan stations are enabled in StateDMI
/**
Writes a Vector of StateMod_Plan objects to a list file.  A header is 
printed to the top of the file, containing the commands used to generate the 
file.  Any strings in the body of the file that contain the field delimiter will be wrapped in "...".
@param filename the name of the file to which the data will be written.
@param delimiter the delimiter to use for separating field values.
@param update whether to update an existing file, retaining the current 
header (true) or to create a new file with a new header.
@param data the Vector of objects to write.  
@throws Exception if an error occurs.
*/
/*
public static void writeListFile(String filename, String delimiter,
boolean update, Vector data) 
throws Exception {
	int size = 0;
	if (data != null) {
		size = data.size();
	}
	
	Vector fields = new Vector();
	fields.add("ID");
	fields.add("Name");
	fields.add("RiverNodeID");
	fields.add("OnOff");
	fields.add("Capacity");
	fields.add("ReplaceResOption");
	fields.add("DailyID");
	fields.add("UserName");
	fields.add("DemandType");
	fields.add("EffAnnual");
	fields.add("IrrigatedAcres");
	fields.add("UseType");
	fields.add("DemandSource");
	fields.add("EffMonthly01");
	fields.add("EffMonthly02");
	fields.add("EffMonthly03");
	fields.add("EffMonthly04");
	fields.add("EffMonthly05");
	fields.add("EffMonthly06");
	fields.add("EffMonthly07");
	fields.add("EffMonthly08");
	fields.add("EffMonthly09");
	fields.add("EffMonthly10");
	fields.add("EffMonthly11");
	fields.add("EffMonthly12");
	int fieldCount = fields.size();

	String[] names = new String[fieldCount];
	String[] formats = new String[fieldCount]; 
	int comp = StateMod_DataSet.COMP_PLANS;
	String s = null;
	for (int i = 0; i < fieldCount; i++) {
		s = (String)fields.elementAt(i);
		names[i] = StateMod_Util.lookupPropValue(comp, "FieldName", s);
		formats[i] = StateMod_Util.lookupPropValue(comp, "Format", s);
	}

	String oldFile = null;	
	if (update) {
		oldFile = IOUtil.getPathUsingWorkingDir(filename);
	}
	
	int j = 0;
	int size2 = 0;
	PrintWriter out = null;
	String[] commentString = { "#" };
	String[] ignoreCommentString = { "#>" };
	String[] line = new String[fieldCount];
	String[] newComments = null;
	String id = null;
	StringBuffer buffer = new StringBuffer();
	StateMod_Diversion div = null;
	StateMod_ReturnFlow rf = null;
	Vector returnFlows = new Vector();
	Vector temp = null;
	
	try {	
		out = IOUtil.processFileHeaders(
			oldFile,
			IOUtil.getPathUsingWorkingDir(filename), 
			newComments, commentString, ignoreCommentString, 0);

		for (int i = 0; i < fieldCount; i++) {
			buffer.append("\"" + names[i] + "\"");
			if (i < (fieldCount - 1)) {
				buffer.append(delimiter);
			}
		}

		out.println(buffer.toString());
		
		for (int i = 0; i < size; i++) {
			div = (StateMod_Diversion)data.elementAt(i);
			
			line[0] = StringUtil.formatString(div.getID(), 
				formats[0]).trim();
			line[1] = StringUtil.formatString(div.getName(), 
				formats[1]).trim();
			line[2] = StringUtil.formatString(div.getCgoto(), 
				formats[2]).trim();
			line[3] = StringUtil.formatString(div.getSwitch(), 
				formats[3]).trim();
			line[4] = StringUtil.formatString(div.getDivcap(), 
				formats[4]).trim();
			line[5] = StringUtil.formatString(div.getIreptype(), 
				formats[5]).trim();
			line[6] = StringUtil.formatString(div.getCdividy(), 
				formats[6]).trim();
			line[7] = StringUtil.formatString(div.getUsername(), 
				formats[7]).trim();
			line[8] = StringUtil.formatString(div.getIdvcom(), 
				formats[8]).trim();
			line[9] = StringUtil.formatString(div.getArea(), 
				formats[9]).trim();
			line[10] = StringUtil.formatString(div.getIrturn(), 
				formats[10]).trim();
			line[11] = StringUtil.formatString(div.getDemsrc(), 
				formats[11]).trim();
			line[12] = StringUtil.formatString(div.getDivefc(), 
				formats[12]).trim();
			line[13] = StringUtil.formatString(div.getDiveff(0), 
				formats[13]).trim();
			line[14] = StringUtil.formatString(div.getDiveff(1), 
				formats[14]).trim();
			line[15] = StringUtil.formatString(div.getDiveff(2), 
				formats[15]).trim();
			line[16] = StringUtil.formatString(div.getDiveff(3), 
				formats[16]).trim();
			line[17] = StringUtil.formatString(div.getDiveff(4), 
				formats[17]).trim();
			line[18] = StringUtil.formatString(div.getDiveff(5), 
				formats[18]).trim();
			line[19] = StringUtil.formatString(div.getDiveff(6), 
				formats[19]).trim();
			line[20] = StringUtil.formatString(div.getDiveff(7), 
				formats[20]).trim();
			line[21] = StringUtil.formatString(div.getDiveff(8), 
				formats[21]).trim();
			line[22] = StringUtil.formatString(div.getDiveff(9), 
				formats[22]).trim();
			line[23] = StringUtil.formatString(div.getDiveff(10),
				formats[23]).trim();
			line[24] = StringUtil.formatString(div.getDiveff(11),
				formats[24]).trim();

			buffer = new StringBuffer();	
			for (j = 0; j < fieldCount; j++) {
				if (line[j].indexOf(delimiter) > -1) {
					line[j] = "\"" + line[j] + "\"";
				}
				buffer.append(line[j]);
				if (j < (fieldCount - 1)) {
					buffer.append(delimiter);
				}
			}

			out.println(buffer.toString());

			temp = div.getReturnFlows();
			size2 = temp.size();
			id = div.getID();
			for (j = 0; j < size2; j++) {
				rf = (StateMod_ReturnFlow)temp.elementAt(j);
				rf.setID(id);
				returnFlows.add(rf);
			}
		}
		out.flush();
		out.close();
		out = null;
	}
	catch (Exception e) {
		if (out != null) {
			out.flush();
			out.close();
		}
		out = null;
		throw e;
	}

	int lastIndex = filename.lastIndexOf(".");
	String front = filename.substring(0, lastIndex);
	String end = filename.substring((lastIndex + 1), filename.length());
	
	String returnFlowFilename = front + "_ReturnFlows." + end;
	StateMod_ReturnFlow.writeListFile(returnFlowFilename, delimiter,
		update, returnFlows,
		StateMod_DataSet.COMP_DIVERSION_STATION_DELAY_TABLES);

	String collectionFilename = front + "_Collections." + end;
	writeCollectionListFile(collectionFilename, delimiter,
		update, data);		
}
	*/

}
